<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="architecture"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Application Architecture</title>

  <para>In this chapter we'll introduce the architecture of Roo-created
  projects. In later chapters we'll cover the architecture of Roo
  itself.</para>

  <para>This chapter focuses on web applications created by Roo, as opposed to
  add-on projects.</para>

  <section xml:id="architecture-overview">
    <title>Architectural Overview</title>

    <para>Spring Roo focuses on the development of enterprise applications
    written in Java. In the current version of Roo these applications
    typically will have a relational database backend, Java Persistence API
    (JPA) persistence approach, Spring Framework dependency injection and
    transactional management, JUnit tests, a Maven build configuration and
    usually a Spring MVC-based front-end that uses JSP for its views. As such
    a Roo-based application is like most modern Java-based enterprise
    applications.</para>

    <para>While most people will be focusing on developing these Spring
    MVC-based web applications, it's important to recognise that Roo does not
    impose any restrictions on the sort of Java applications that can be built
    with it. Even with Roo 1.0.0 it was easy to build any type of
    self-contained application. Some examples of the types of requirements you
    can easily address with the current version of Roo include (but are not
    limited to):</para>

    <itemizedlist>
      <listitem>
        <para>Listening for messages on a JMS queue and sending replies over
        JMS or SMTP (Roo can easily <link
        linkend="command-index-jms-setup">set up JMS</link> message producers,
        consumers and <link
        linkend="command-index-email-sender-setup">SMTP</link>)</para>
      </listitem>

      <listitem>
        <para>Writing a services layer (perhaps annotated with Spring's
        @Service <link
        xlink:href="http://static.springsource.org/spring/docs/3.0.0.RELEASE/spring-framework-reference/html/beans.html#beans-stereotype-annotations">stereotype
        annotation</link>) and exposing it using a remoting protocol to a rich
        client (Spring's <link
        xlink:href="http://static.springsource.org/spring/docs/3.0.0.RELEASE/spring-framework-reference/html/remoting.html">remoting
        services</link> will help here)</para>
      </listitem>

      <listitem>
        <para>Executing a series of predefined actions against the database,
        perhaps in conjunction with Spring's new @Scheduled or @Async <link
        xlink:href="http://static.springsource.org/spring/docs/3.0.0.RELEASE/spring-framework-reference/html/scheduling.html#scheduling-annotation-support">timer
        annotations</link></para>
      </listitem>

      <listitem>
        <para>Experimentation with the latest <link
        linkend="architecture-critical-technologies-spring">Spring</link> and
        <link
        linkend="architecture-critical-technologies-aspectj">AspectJ</link>
        features with minimal time investment</para>
      </listitem>
    </itemizedlist>

    <para>One of the major differences between Roo and traditional,
    hand-written applications is we don't add layers of abstraction
    unnecessarily. Most traditional Java enterprise applications will have a
    DAO layer, services layer, domain layer and controller layer. In a typical
    Roo application you'll only use an <link
    linkend="architecture-entities">entity layer</link> (which is similar to a
    domain layer) and a <link linkend="architecture-web">web layer</link>. As
    indicated by the list above, a <link
    linkend="architecture-services">services layer</link> might be added if
    your application requires it, although a <link
    linkend="architecture-dao">DAO layer</link> is extremely rarely added.
    We'll look at some of these layering conventions (and the rationale for
    them) as we go through the rest of this chapter.</para>
  </section>

  <section xml:id="architecture-critical-technologies">
    <title>Critical Technologies</title>

    <para>Two technologies are very important in all Roo projects, those being
    AspectJ and Spring. We'll have a look at how Roo-based applications use
    these technologies in this section.</para>

    <section xml:id="architecture-critical-technologies-aspectj">
      <title>AspectJ</title>

      <para>AspectJ is a powerful and mature aspect oriented programming (AOP)
      framework that underpins many large-scale systems. Spring Framework has
      offered extensive support for AspectJ since 2004, with Spring 2.0
      adopting AspectJ's pointcut definition language even for expressing
      Spring AOP pointcuts. Many of the official Spring projects offer support
      for AspectJ or are themselves heavily dependent on it, with several
      examples including Spring Security (formerly Acegi Security System for
      Spring), Spring Insight, SpringSource tc Server, SpringSource dm Server,
      Spring Enterprise and Spring Roo.</para>

      <para>While AspectJ is most commonly known for its aspect oriented
      programming (AOP) features such as applying advice at defined pointcuts,
      Roo projects use AspectJ's powerful inter-type declaration (ITD)
      features. This is where the real magic of Roo comes from, as it allows
      us to code generate members (artifacts like methods, fields etc) in a
      different compilation unit (i.e. source file) from the normal .java code
      you'd write as a developer. Because the generated code is in a separate
      file, we can maintain that file's lifecycle and contents completely
      independently of whatever you are doing to the .java files. Your .java
      files do not need to do anything unnatural like reference the generated
      ITD file and the whole process is completely transparent.</para>

      <para>Let's have a look at how ITDs work. In a new directory, type the
      following commands and note the console output:</para>

      <programlisting>roo&gt; <emphasis role="bold">project --topLevelPackage com.aspectj.rocks</emphasis>
roo&gt; <emphasis role="bold">persistence setup --database HYPERSONIC_IN_MEMORY --provider HIBERNATE</emphasis>
roo&gt; <emphasis role="bold">entity --class ~.Hello</emphasis>
Created SRC_MAIN_JAVA/com/aspectj/rocks
Created SRC_MAIN_JAVA/com/aspectj/rocks/Hello.java
Created SRC_MAIN_JAVA/com/aspectj/rocks/Hello_Roo_Entity.aj
Created SRC_MAIN_JAVA/com/aspectj/rocks/Hello_Roo_ToString.aj
Created SRC_MAIN_JAVA/com/aspectj/rocks/Hello_Roo_Configurable.aj
roo&gt; <emphasis role="bold">field string --fieldName comment</emphasis>
Managed SRC_MAIN_JAVA/com/aspectj/rocks/Hello.java
Managed SRC_MAIN_JAVA/com/aspectj/rocks/Hello_Roo_JavaBean.aj
Managed SRC_MAIN_JAVA/com/aspectj/rocks/Hello_Roo_ToString.aj</programlisting>

      <para>Notice how there is a standard <code>Hello.java</code> file, as
      well as a series of <code>Hello_Roo_*.aj</code> files. Any file ending
      in <code>*_Roo_*.aj</code> is an AspectJ ITD and will be managed by Roo.
      You should not edit these files directly, as Roo will automatically
      maintain them (this includes even deleting files that aren't required,
      as we'll see shortly).</para>

      <para>The <code>Hello.java</code> is just a normal Java file. It looks
      like this:</para>

      <programlisting>package com.aspectj.rocks;

import javax.persistence.Entity;
import org.springframework.roo.addon.javabean.RooJavaBean;
import org.springframework.roo.addon.tostring.RooToString;
import org.springframework.roo.addon.entity.RooEntity;

@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Hello {

    private String comment;
}</programlisting>

      <para>As shown, there's very little in the <code>.java</code> file.
      There are some annotations, plus of course the field we added. Note that
      Roo annotations are always source-level retention, meaning they're not
      compiled into your <code>.class</code> file. Also, as per our usability
      goals you'll note that Roo annotations also always start with
      <code>@Roo*</code> to help you find them with code assist.</para>

      <para>By this stage you're probably wondering what the ITD files look
      like. Let's have a look at one of them,
      <code>Hello_Roo_ToString.aj</code>:</para>

      <programlisting>package com.aspectj.rocks;

import java.lang.String;

privileged aspect Hello_Roo_ToString {
    
    public String Hello.toString() {    
        StringBuilder sb = new StringBuilder();        
        sb.append("Id: ").append(getId()).append(", ");        
        sb.append("Version: ").append(getVersion()).append(", ");        
        sb.append("Comment: ").append(getComment());        
        return sb.toString();        
    }    
    
}</programlisting>

      <para>Notice how the ITD is very similar to Java code. The main
      differences are that it is declared with "<code>privileged
      aspect</code>", plus each member identifies the target type (in this
      case it is "<code>Hello.toString</code>", which means add the
      "<code>toString</code>" method to the "<code>Hello</code>" type). The
      compiler will automatically recognize these ITD files and cause the
      correct members to be compiled into <code>Hello.class</code>. We can see
      that quite easily by using Java's <code>javap</code> command. All we
      need to do is run the compiler and view the resulting class. From the
      same directory as you created the project in, enter the following
      commands and observe the final output:</para>

      <programlisting>$ <emphasis role="bold">mvn compile</emphasis>
$ <emphasis role="bold">javap -classpath target/classes/.:target/test-classes/. com.aspectj.rocks.Hello</emphasis>
Compiled from "Hello.java"
public class com.aspectj.rocks.Hello extends java.lang.Object implements org.springframework.beans.factory.aspectj.ConfigurableObject{
    transient javax.persistence.EntityManager entityManager;
    public com.aspectj.rocks.Hello();
    public static java.lang.String ajc$get$comment(com.aspectj.rocks.Hello);
    public static void ajc$set$comment(com.aspectj.rocks.Hello, java.lang.String);
    public static java.lang.Long ajc$get$id(com.aspectj.rocks.Hello);
    public static void ajc$set$id(com.aspectj.rocks.Hello, java.lang.Long);
    public static java.lang.Integer ajc$get$version(com.aspectj.rocks.Hello);
    public static void ajc$set$version(com.aspectj.rocks.Hello, java.lang.Integer);
    static {};
    public static long countHelloes();
    public static final javax.persistence.EntityManager entityManager();
    public static java.util.List findAllHelloes();
    public static com.aspectj.rocks.Hello findHello(java.lang.Long);
    public static java.util.List findHelloEntries(int, int);
    public void flush();
    public java.lang.String getComment();
    public java.lang.Long getId();
    public java.lang.Integer getVersion();
    public com.aspectj.rocks.Hello merge();
    public void persist();
    public void remove();
    public void setComment(java.lang.String);
    public void setId(java.lang.Long);
    public void setVersion(java.lang.Integer);
    public java.lang.String toString();
}</programlisting>

      <para>While the <code>javap</code> output might look a little daunting
      at first, it represents all the members that Roo has added (via AspectJ
      ITDs) to the original <code>Hello.java</code> file. Notice there isn't
      just the <code>toString</code> method we saw in the earlier ITD, but
      we've also made the <code>Hello</code> class implement Spring's
      <code>ConfigurableObject</code> interface, provided access to a JPA
      <code>EntityManager</code>, included a range of convenient persistence
      methods plus even getters and setters. All of these useful features are
      automatically maintained in a round-trip compatible manner via the
      ITDs.</para>

      <para>A careful reader might be wondering about the long field names
      seen for introduced fields. You can see that these field names start
      with "<code>ajc$</code>" in the output above. The reason for this is to
      avoid name collisions with fields you might have in the
      <code>.java</code> file. The good news is that you won't ever need to
      deal with this unless you're trying to do something clever with
      reflection. It's just something to be aware of for introduced fields in
      particular. Note that the names of methods and constructors are never
      modified.</para>

      <para>Naturally as a normal Roo user you won't need to worry about the
      internals of ITD source code and the resulting <code>.class</code>
      files. Roo automatically manages all ITDs for you and you never need
      deal with them directly. It's just nice to know how it all works under
      the hood (Roo doesn't believe in magic!). The benefit of this ITD
      approach is how easily and gracefully Roo can handle code generation for
      you.</para>

      <para>To see this in action, go and edit the <code>Hello.java</code> in
      your favourite text editor with Roo running. Do something simple like
      add a new field. You'll notice the <code>Hello_Roo_ToString.aj</code>
      and <code>Hello_Roo_JavaBean.aj</code> files are instantly and
      automatically updated by Roo to include your new field. Now go and write
      your own <code>toString</code> method in the <code>.java</code> file.
      Notice Roo deletes the <code>Hello_Roo_ToString.aj</code> file, as it
      detects your <code>toString </code>method should take priority over a
      generated <code>toString</code> method. But let's say you want a
      generated <code>toString</code> as well, so change the
      <code>Hello.java</code>'s <code>@RooToString</code> annotation to read
      <code>@RooToString(toStringMethod="generatedToString")</code>. Now
      you'll notice the <code>Hello_Roo_ToString.aj</code> file is immediately
      re-created, but this time it introduces a <code>generatedToString</code>
      method instead of the original <code>toString</code>. If you comment out
      both fields in <code>Hello.java</code> you'll also see that Roo deletes
      both ITDs. You can also see the same effect by quitting the Roo shell,
      making any changes you like, then restarting the Roo shell. Upon restart
      Roo will automatically perform a scan and discover if it needs to make
      any changes.</para>

      <para>Despite the admittedly impressive nature of ITDs, AspectJ is also
      pretty good at aspect oriented programming features like pointcuts and
      advice! To this end Roo applications also use AspectJ for all other AOP
      requirements. It is AspectJ that provides the AOP so that classes are
      dependency injected with singletons when instantiated and transactional
      services are called as part of method invocations. All Roo applications
      are preconfigured to use the Spring Aspects project, which ships as part
      of Spring Framework and represents a comprehensive "aspect library" for
      AspectJ.</para>
    </section>

    <section xml:id="architecture-critical-technologies-spring">
      <title>Spring</title>

      <para>Spring Roo applications all use Spring. By "Spring" we not only
      mean Spring Framework, but also the other Spring projects like Spring
      Security and Spring Web Flow. Of course, only Spring Framework is
      installed into a user project by default and there are fine-grained
      commands provided to install each additional Spring project beyond
      Spring Framework.</para>

      <para>All Roo applications use Spring Aspects, which was mentioned in
      the <link linkend="architecture-critical-technologies-aspectj">AspectJ
      section</link> and ensures Spring Framework's <code>@Configurable</code>
      dependency injection and transactional advice is applied. Furthermore,
      Roo applications use Spring's annotation-driven component scanning by
      default and also rely on Spring Framework for instantiation and
      dependency injection of features such as JPA providers and access to
      database connection pools. Many of the optional features that can be
      used in Roo applications (like JMS and SMTP messaging) are also built
      upon the corresponding Spring Framework dependency injection support and
      portable service abstractions.</para>

      <para>Those Roo applications that include a web controller will also
      receive Spring Framework 3's MVC features such as its conversion API,
      web content negotiation view resolution and REST support. It is possible
      (and indeed encouraged) to write your own web Spring MVC controllers in
      Roo applications, and you are also free to use alternate page rendering
      technologies if you wish (i.e. not just JSP).</para>

      <para>Generally speaking Roo will not modify any Spring-related
      configuration or setting file (e.g. properties) unless specifically
      requested via a shell command. Roo also ensures that whenever it
      creates, modifies or deletes a file it explicitly tells you about this
      via a shell message. What this means is you can safely edit your Spring
      application context files at any time and without telling Roo. This is
      very useful if the default configuration offered by Roo is unsuitable
      for your particular application's needs.</para>

      <para>Because Spring projects are so extensively documented, and Roo
      just uses Spring features in the normal manner, we'll refrain from
      duplicating Spring's documentation in this section. Instead please refer
      to the excellent Spring documentation for guidance, which can be found
      in the downloadable distribution files and also on the <link
      xlink:href="http://www.springsource.org/documentation">Spring web
      site</link>.</para>
    </section>
  </section>

  <section xml:id="architecture-entities">
    <title>Entity Layer</title>

    <para>When people use Roo, they will typically start a new project using
    the steps detailed in the <link linkend="beginning">Beginning With Roo:
    The Tutorial</link> chapter. That is, they'll start by creating the
    project, installing some sort of persistence system, and then beginning to
    create entities and add fields to them. As such, entities and fields
    represent the first point in a Roo project that you will be expressing
    your problem domain.</para>

    <para>The role of an entity in your Roo-based application is to model the
    persistent "domain layer" of your system. As such, a domain object is
    specific to your problem domain but an entity is a special form of a
    domain object that is stored in the database. By default a single entity
    will map to a single table in your database, and a single field within
    your entity class will map to a single column within the corresponding
    table. However, like most things in Roo this is easily customised using
    the relevant standard (in this case, JPA annotations). Indeed most of the
    common customisation options (like specifying a custom column or table
    name etc) can be expressed directly in the relevant Roo command, freeing
    you from even needing to know which annotation(s) should be used.</para>

    <para>Let's consider a simple entity that has been created using the <link
    linkend="command-index-entity">entity</link> command and following it with
    a single <link linkend="command-index-field-commands">field</link>
    command:</para>

    <programlisting>package com.springsource.vote.domain;

import javax.persistence.Entity;
import org.springframework.roo.addon.javabean.RooJavaBean;
import org.springframework.roo.addon.tostring.RooToString;
import org.springframework.roo.addon.entity.RooEntity;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Choice {

    @NotNull
    @Size(min = 1, max = 30)
    private String namingChoice;

    @Size(max = 80)
    private String description;
}</programlisting>

    <para>The above entity is simply a JPA entity that contains two fields.
    The two fields are annotated with JavaBean Validation API (JSR 303)
    annotations, which are useful if your JPA provider supports this standard
    (as is the case if you nominate Hibernate as your JPA provider) or you are
    using a Roo-scaffolded web application front end (in which case Roo will
    use Spring Framework 3's JSR 303 support). Of course you do not need to
    use the JavaBean Validation API annotations at all, but if you would like
    to use them the relevant Roo field commands provide tab-completion
    compatible options for each. The first time you use one of these Roo field
    commands, Roo will add required JavaBean Validation API libraries to your
    project (i.e. these libraries will not be in your project until you decide
    to first use JavaBean Validation).</para>

    <para>What's interesting about the above entity is what you can actually
    do with it. There are a series of methods automatically added into the
    <code>Choice.class</code> courtesy of Roo code-generated and maintained
    AspectJ ITDs. These include static methods for retrieving instances of
    Choice, JPA facade methods for persisting, removing, merging and flushing
    the entity, plus accessors and mutators for both the identifier and
    version properties. You can fine-tune these settings by modifying
    attributes on the <code>@RooEntity</code> annotation. You can also have
    Roo remove these services by simply removing the <code>@RooEntity</code>
    annotation from the class, in which case you'll be left with a normal JPA
    @Entity that you'll need to manage by hand (e.g. provide your own
    persistence methods, identifier, version etc).</para>

    <para>The <code>@RooJavaBean</code> annotation causes an accessor and
    mutator (getter and setter) to automatically be generated for each field
    in the class. These accessors and mutators are automatically maintained in
    an AspectJ ITD by Roo. If you write your own accessor or mutator in the
    normal .java file, Roo will automatically remove the corresponding
    generated method from the ITD. You can also remove the
    <code>@RooJavaBean</code> annotation if you don't want any generated
    accessors or mutators (although those related to the version and
    identifier fields will remain, as they are associated with
    <code>@RooEntity</code> instead of <code>@RooJavaBean</code>).</para>

    <para>Finally, the <code>@RooToString</code> annotation causes Roo to
    create and maintain a <code>public String toString()</code> method in a
    separate ITD. This method currently is used by any scaffolded web
    controllers if they need to display a related entity. The generated method
    takes care to avoid circular references that are commonly seen in
    bidirectional relationships involving collections. The method also formats
    Java <code>Calendar</code> objects in an attractive manner. As always, you
    can write your own <code>toString()</code> method by hand and Roo will
    automatically remove its generated <code>toString()</code> method, even if
    you still have the <code>@RooToString</code> annotation present. You can
    of course also remove the <code>@RooToString </code>annotation if you no
    longer wish to have a generated <code>toString()</code> method.</para>

    <para>Before leaving this discussion on entities, it's worth mentioning
    that you are free to create your own entity <code>.java</code> classes by
    hand. You do not need to use the Roo shell commands to create entities or
    maintain their fields - just use any IDE. Also, you are free to use the
    <code>@RooToString</code> or <code>@RooJavaBean</code> (or both)
    annotations on any class you like. This is especially useful if you have a
    number of domain objects that are not persisted and are therefore not
    entities. Roo can still help you with those objects.</para>
  </section>

  <section xml:id="architecture-web">
    <title>Web Layer</title>

    <para>Roo 1.0 can optionally provide a scaffolded Spring MVC web layer.
    The scaffolded MVC web layer features are explored in some depth in the
    <link linkend="beginning">Beginning With Roo: The Tutorial</link> chapter,
    including how to customise the appearance. From an architectural
    perspective, the scaffolded layer includes a number of URL rewriting rules
    to ensure requests can be made in accordance with REST conventions. Roo's
    scaffolding model also includes Apache Tiles, Spring JavaScript, plus
    ensures easy setup of Spring Security with a single command.</para>

    <para>In Spring Roo 1.1 we also added comprehensive support for Google Web
    Toolkit (GWT). This allows you to build Generation IV web HTML5-based web
    front-ends. These front-ends access the Spring backend using highly
    optimized remoting protocols, and the GWT application represents the GWT
    team's recommended best practice architecture. In fact, the GWT team at
    Google wrote most of the Roo GWT add-on, so you can be sure it uses the
    best GWT 2.1 features.</para>

    <para>Scaffolded web controllers always delegate directly to methods
    provided on an <code>@RooEntity</code> class. For maximum compatibility
    with scaffolded controllers, it is recommended to observe the default
    identifier and version conventions provided by <code>@RooEntity</code>
    implementations. If you write a web controller by hand (perhaps with the
    assistance of the <link
    linkend="command-index-controller-class">controller class</link> command),
    it is recommended you also use the methods directly exposed on entities.
    Most Roo applications will place their business logic between the entities
    and web controllers, with only occasional use of services layers. Please
    refer to the <link linkend="architecture-services">services layer</link>
    section for a more complete treatment of when you'd use a services
    layer.</para>
  </section>

  <section xml:id="architecture-services">
    <title>Optional Services Layer</title>

    <para>As discussed at the start of this chapter, web applications are the
    most common type of application created with Roo 1.0.0. A web application
    will rarely <emphasis>require</emphasis> a services layer, as most logic
    can be placed in the web controller handle methods and the remainder in
    entity methods. Still, a services layer makes sense in specific scenarios
    such as:</para>

    <itemizedlist>
      <listitem>
        <para>There is business logic that spans multiple entities and that
        logic does not naturally belong in a specific entity</para>
      </listitem>

      <listitem>
        <para>You need to invoke business logic outside the scope of a natural
        web request (e.g. a timer task)</para>
      </listitem>

      <listitem>
        <para>Remote client access is required and it is therefore more
        convenient to simply expose the methods via a remoting protocol</para>
      </listitem>

      <listitem>
        <para>An architectural policy requires the use of a services
        layer</para>
      </listitem>

      <listitem>
        <para>A higher level of cohesion is sought in the web layer, with the
        web layer solely responsible for HTTP-related management and the
        services layer solely responsible for business logic</para>
      </listitem>

      <listitem>
        <para>A greater level of testing is desired, which is generally easier
        to mock than simulating web requests</para>
      </listitem>

      <listitem>
        <para>it is preferred to place transactional boundaries and security
        authorization metadata on the services layer (as opposed to a web
        controller)</para>
      </listitem>
    </itemizedlist>

    <para>As shown, there are a large number of reasons why services layers
    remain valuable. However, Roo does not code generate services layers
    because they are not strictly essential to building a normal web
    application and Roo achieves separation of concern via its AspectJ
    ITD-based architecture.</para>

    <para>If you would like to use a services layer, it's as simple as
    creating a new class (and optional interface) and annotating that class
    with Spring's <code>@Services</code> <link
    xlink:href="http://static.springsource.org/spring/docs/3.0.0.RELEASE/spring-framework-reference/html/beans.html#beans-stereotype-annotations">stereotype
    annotation</link>. Just ensure the services layer class appears under the
    same package as you nominated in the <link
    linkend="command-index-project">create project</link> command, and Spring
    Framework will then automatically detect your services layer class when it
    launches your application.</para>
  </section>

  <section xml:id="architecture-dao">
    <title>Goodbye DAOs</title>

    <para>One change many existing JEE developers will notice when using
    Roo-based applications is that there is no DAO layer (or "Repository"
    layer). As with the <link linkend="architecture-services">services
    layer</link>, we have removed the DAO layer because it is not strictly
    essential to creating the typical web applications that most people are
    trying to build.</para>

    <para>If we reflect for a moment on the main motivations for DAOs, it is
    easy to see why these are not applicable in Roo applications:</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>Testing</emphasis>: In a normal application a DAO
          provides an interface that could be easily stubbed as part of unit
          testing. The interesting point about testing is that most people use
          mocking instead of stubbing in modern applications, making it
          attractive to simply mock the persistence method or two that you
          actually require for a test (rather than the crudeness of stubbing
          an entire DAO interface). In Roo-based applications you simply mock
          the persistence-related methods that have been introduced to the
          entity. You can use normal mocking approaches for the instance
          methods on the Roo entity, and use Spring Aspect's
          <code>@MockStaticEntityMethods</code> support for the static finder
          methods.</para>
        </listitem>

        <listitem>
          <para><emphasis>Separation of concern</emphasis>: One reason for
          having a DAO layer is that it allows a higher cohesion
          object-oriented design to be pursued. The high cohesion equates to a
          separation of concern that reduces the conceptual weight of
          implementing the system. In a Roo-based application separation of
          concern is achieved via the separate ITDs. The conceptual weight is
          also reduced because Roo handles the persistence methods rather than
          force the programmer to deal with them. Therefore separation of
          concern still exists in a Roo application without the requirement
          for a DAO layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>Pluggable implementations</emphasis>: A further
          benefit of DAOs is they simplify the switching from one persistence
          library to another. In modern applications this level of API
          abstraction is provided via JPA. As Roo uses JPA in its generated
          methods, the ability to plug in an alternate implementation is
          already fully supported despite there being no formal DAO layer. You
          can see this yourself by issuing the <link
          linkend="command-index-persistence-setup">persistence setup
          </link>command and specifying alternate implementations.</para>
        </listitem>

        <listitem>
          <para><emphasis>Non-JPA persistence</emphasis>: It is possible that
          certain entities are stored using a technology that does not have a
          JPA provider. In this case Roo does not support those entities out
          of the box. However, if only a small number of entities are affected
          by this consideration there is no reason one or more hand-written
          ITDs could not be provided by the user in order to maintain
          conceptual parity with the remainder of the Roo application (which
          probably does have some JPA). If a large number of entities are
          affected, the project would probably benefit from the user writing a
          Roo add-on which will automatically manage the ITDs just as Roo does
          for JPA.</para>
        </listitem>

        <listitem>
          <para><emphasis>Security authorisation</emphasis>: Sometimes DAOs
          are used to apply security authorisation rules. It is possible to
          protect persistence methods on the DAOs and therefore go relatively
          low in the control flow to protecting the accessibility of entities.
          In practice this rarely works well, though, as most authorisation
          workflows will target a use case as opposed to the entities required
          to implement a use case. Further, the approach is unsafe as it is
          possible to transitively acquire one entity from another without
          observing the authorisation rules (e.g.
          <code>person.getPartner().getChildren().get(1).setFirstName("Ben")</code>).
          It is also quite crude in that it does not support transparent
          persistence correctly, in that the example modification of the first
          name would flush to the database without any authorisation check
          (assuming this mutative operation occurred within the context of a
          standard transactional unit of work). While it's possible to work
          around many of these issues, authorisation is far better tackled
          using other techniques than the DAO layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>Security auditing</emphasis>: In a similar argument
          to authorisation, sometimes DAOs are advocated for auditing
          purposes. For the same types of reasons expressed for authorisation,
          this is a suboptimal approach. A better way is to use AOP (e.g.
          AspectJ field set pointcuts), a JPA flush event handle, or a
          trigger-like model within the database.</para>
        </listitem>

        <listitem>
          <para><emphasis>Finders</emphasis>: If you review existing DAOs,
          you'll find the main difference from one to another is the finder
          methods they expose. Dynamic finders are automatically supported by
          Roo and introduced directly to the entity, relieving the user from
          needing DAOs for this reason. Furthermore, it is quite easy to
          hand-write a finder within the entity (or an ITD that adds the
          finder to the entity if a separate compilation unit is
          desired).</para>
        </listitem>

        <listitem>
          <para><emphasis>Architectural reasons</emphasis>: Often people
          express a preference for a DAO because they've always done it that
          way. While maintaining a proven existing approach is generally
          desirable, adopting Roo for an application diminishes the value of a
          DAO layer to such an extent that it leaves little (if any)
          engineering-related reasons to preserve it.</para>
        </listitem>
      </itemizedlist></para>

    <para>It's also worth observing that most modern RAD frameworks avoid DAO
    layers and add persistence methods directly to entities. If you compare
    similar technologies to Roo, you will see this avoidance of a DAO layer is
    commonplace, mainstream and does not cause problems.</para>

    <para>Naturally you can still write DAOs by hand if you want to, but the
    majority of Roo add-ons will not be compatible with such DAOs. As such you
    will not receive automated testing or MVC controllers that understand your
    hand-written DAOs. Our advice is therefore not to hand write DAOs. Simply
    use the entity methods provided by <code>@RooEntity</code>, as it's
    engineering-wise desirable and it's also far less effort for you to write
    and maintain.</para>

    <para>If you are interested in DAO support despite the above, <link
    xlink:href="http://jira.springframework.org/browse/ROO-301">ROO-301</link>
    represents an enhancement request for more flexibility around DAOs. You
    are invited to track this enhancement request or vote for it if you would
    like to see this. We plan on actioning this enhancement request in the
    next version of Roo.</para>
  </section>
</chapter>
