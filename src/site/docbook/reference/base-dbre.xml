<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="base-dbre"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/1999/xhtml"
         xmlns:ns3="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Incremental Database Reverse Engineering (DBRE) Add-On</title>

  <para>The incremental database reverse engineering (DBRE) add-on allows you
  to generate an application tier of JPA 2.0 entities based on the tables in
  your database. DBRE will also incrementally maintain your application tier
  if you add or remove tables and columns.</para>

  <section>
    <title>Introduction</title>

    <section>
      <title>What are the benefits of Roo's incremental reverse
      engineering?</title>

      <para>Traditional JPA reverse engineering tools are designed to
      introspect a database schema and produce a Java application tier once.
      Roo's incremental database reverse engineering feature differs because
      it has been designed to enable developers to repeatedly re-introspect a
      database schema and update their Java application. For example, consider
      if a column or table has been dropped from the database (or renamed).
      With Roo the re-introspection process would discover this and helpfully
      report errors in the Java tier wherever the now-missing field or entity
      was referenced. In simple terms, incremental database reverse
      engineering ensures Java type safety and easy application maintenance
      even if the database schema is constantly evolving. Just as importantly,
      Roo's incremental reverse engineering is implemented using the same
      unique design philosophy as the rest of Roo. This means very fast
      application delivery, clutter-free .java source files, extensive
      usability features in the shell (such as tab completion and hinting) and
      so on.</para>
    </section>

    <section>
      <title>How does DBRE work?</title>

      <para>The DBRE commands (see <xref linkend="dbre_commands" /> below)
      make live connections to the database configured in your Roo project and
      obtain information about your using the database metadata from the
      standard java.sql.DatabaseMetadata object, which is implemented by the
      JDBC driver. When the database is reverse engineered, this information
      is converted to XML and is stored and maintained in the .roo-dbre file
      in the root directory of your project. DBRE creates JPA entities based
      on the table names in your database and fields based on the columns in
      the tables. Relationships between entities are also created using the
      imported and exported key information obtained from the database
      metadata.</para>

      <para>DBRE generates entity classes with names that are derived from the
      associated table name using a simple algorithm. If a table's name
      contains an undercore, hyphen, forward or back slash character, an upper
      case letter is substituted for each of these characters. This is also
      similar for column and field names. The following table contains some
      examples.</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Table name</entry>

              <entry align="center">Generated entity class name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>order</entry>

              <entry>Order.java</entry>
            </row>

            <row>
              <entry>line_item</entry>

              <entry>LineItem.java</entry>
            </row>

            <row>
              <entry>EAM_MEASUREMENT_DATA_1H</entry>

              <entry>EamMeasurementData1h.java</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
  </section>

  <section>
    <title>Installation</title>

    <para>DBRE supports most of the relational databases that can be
    configured for Roo-generated projects such as <link
    xlink:href="http://www.mysql.com/">MySQL</link> and <link
    xlink:href="http://www.postgresql.org/">PostgreSQL</link> and the
    OSGi-enabled JDBC drivers for these databases are shipped with the Roo
    distribution zip file. However, due to the physical size of some
    database's JDBC driver jars, Roo does not include these jars but does
    provide an installation script called install-jdbc-drivers.roo that can be
    run as a post-installtion step after installing Roo. To install the
    remaining drivers, execute the Roo command:</para>

    <para><programlisting>roo&gt; script --file install-jdbc-drivers.roo</programlisting></para>

    <para>This command will install the JDBC drivers for <link
    xlink:href="http://www.oracle.com/index.html">Oracle</link>, <link
    xlink:href="http://hsqldb.org/">HSQL</link>, <link
    xlink:href="http://www.h2database.com/html/main.html">H2</link>, <link
    xlink:href="http://jt400.sourceforge.net/">JTOpen</link> (for DB2/400),
    <link xlink:href="http://jtds.sourceforge.net/">jTDS</link> (for MS SQL
    and Sybase), <link xlink:href="http://db.apache.org/derby/">Apache
    Derby</link>, and <link
    xlink:href="http://www.firebirdsql.org/">Firebird</link>. Note that this
    is a one-time-only installation step and is not required to be executed
    again unless you delete the Roo installation directory and re-install
    Roo.</para>

    <para><emphasis role="bold">Note</emphasis>: currently there is no
    open-source JDBC driver for DB2 and Roo does not provide an OSGi driver
    for this database. If you are a DB2 user, you will need to obtain an
    OSGi-enabled driver from IBM or wrap your own DB2 driver jars using Roo's
    wrapping facility.</para>
  </section>

  <section>
    <title xml:id="dbre_commands">DBRE Addon commands</title>

    <para>After you have installed all the JDBC drivers, you can introspect
    and reverse engineer the database configured for your project. DBRE has
    two commands:</para>

    <orderedlist>
      <listitem>
        <para><programlisting>roo&gt; <emphasis role="bold">database introspect --schema</emphasis> --file</programlisting></para>

        <para>This command displays the database structure, or schema, in XML
        format. The --schema is mandatory and for databases which supports
        schemas, you can press tab to display a list of schemas from your
        database. You can use the --file option to save the information to the
        specified file.</para>

        <para><emphasis role="bold">Note</emphasis>: the term "schema" is not
        used by all databases, such as MySQL and Firebird, and for these
        databases the target database name is contained in the JDBC URL
        connection string. However the --schema option is still required but
        Roo's Tab assist feature will display "no-schema-required".</para>
      </listitem>

      <listitem>
        <para><programlisting>roo&gt; <emphasis role="bold">database reverse engineer --schema</emphasis> --package</programlisting></para>

        <para>This command creates JPA entiies in your project representing
        the tables and columns in your database. As for the database
        introspect command, the --schema option is required and tab assistance
        is available. You can use the --package option to specify a Java
        package where your entities will be created.</para>

        <para>Since the DBRE Add-on provides incremental database reverse
        engineering, you can execute the command as many times as you want and
        your JPA entities will be maintained by Roo, that is, new fields will
        be added if new columns are added to a table, or fields will be
        removed if columns are deleted. Entities are also deleted in certain
        circumstances if their corresponding tables are dropped.</para>

        <para>If you do not specify the --package option on second and
        subsequent executions of the database reverse engineer command, new
        entities will be created in the same package as they were previously
        created in.</para>
      </listitem>
    </orderedlist>
  </section>

  <section>
    <title>The @RooDbManaged annotation</title>

    <para>The @RooDbManaged annotation is added to all new entities created by
    executing the database reverse engineer command. Other Roo annotations,
    @RooEntity, @RooJavaBean, and @RooToString are also added to the entity
    class. The attribute "automaticallyDelete" is added to the @RooDbManaged
    annotation and is set to "true" so that Roo can delete the entity if the
    associated table has been dropped. However, if "automaticallyDelete" is
    set to "false", or if any annotations, fields, constructors, or methods
    have been added to the entity (ie in the .java file), or if any of the Roo
    annotations are removed, the entity will not be deleted.</para>

    <para>The presence of the @RooDbmanaged annotation on an entity class
    triggers the creation of an AspectJ inter-type declaration (ITD) ".aj"
    file where fields and their getters and setters are stored matching the
    columns in the table. For example, if an entity called Employee.java is
    created by the database reverse engineer command, a file called
    Employee_Roo_DbManaged.aj is also created and maintained by Roo. All the
    columns of the matching employee table will cause fields to be created in
    the entity's DbManaged ITD. An example of a dbre-created entity is as
    follows:</para>

    <para><programlisting>@RooJavaBean
@RooToString
@RooDbManaged(automaticallyDelete = true)
@RooEntity(table = "employee", schema = "expenses")
public class Employee {
}</programlisting></para>

    <para>Along with the standard entity, toString, configurable ITDs, a
    DbManaged ITD is created if there are more columns in the employee table
    apart from a primary key column. For example, if the employee table has
    mandatory employee name and employee number columns, and a nullable age
    column the ITD could look like this:</para>

    <para><programlisting>privileged aspect Employee_Roo_DbManaged {
    
    @Column(name = "employee_number")
    @NotNull
    private String Employee.employeeNumber;
    
    public String Employee.getEmployeeNumber() {
        return this.employeeNumber;
    }
    
    public void Employee.setEmployeeNumber(String employeeNumber) {
        this.employeeNumber = employeeNumber;
    }

    @Column(name = "employee_name", length = "100")
    @NotNull
    private String Employee.employeeName;
    
    public String Employee.getEmployeeName() {
        return this.employeeName;
    }
    
    public void Employee.setEmployeeName(String employeeName) {
        this.employeeName = employeeName;
    }

    @Column(name = "age")
    private Integer Employee.age;
    
    public Integer Employee.getAge() {
        return this.age;
    }
    
    public void Employee.setAge(Integer age) {
        this.age = age;
    }
...
}</programlisting></para>

    <para>If you do not want DBRE to manage your entity any more, you can
    "push-in" refactor the fields and methods in the DbManaged ITD and remove
    the @RooDbManaged annotation from the .java file.</para>
  </section>

  <section>
    <title>Supported JPA 2.0 features</title>

    <para>DBRE will generate and maintain primary key fields, including
    composite keys, entity relationships such as many-valued and single-valued
    associations, and other fields annotated with the JPA @Column
    annotation.</para>

    <para>The following sections describe the features currently
    supported.</para>

    <section>
      <title>Simple primary keys</title>

      <para>For a table with a single primary key column, DBRE causes an
      identifier field to be generated in the entity ITD annotated with @Id
      and @Column. This is similar to executing the entity command by
      itself.</para>
    </section>

    <section>
      <title>Composite primary keys</title>

      <para>For tables with two or more primary key columns, DBRE will
      generate a primary key class annotated with @RooIdentifier(dbManaged =
      true) and add the "identifierType" attribute with the identifier class
      name to the @RooEntity annotation in the entity class. For example, a
      line_item table has two primary keys, line_item_id and order_id. DBRE
      will generate the LineItem entity class and LineItemPK identifier class
      as follows:</para>

      <para><programlisting>@RooJavaBean
@RooToString
@RooDbManaged(automaticallyDelete = true)
@RooEntity(identifierType = LineItemPK.class, table = "line_item", schema = "order")
public class LineItem {
}</programlisting></para>

      <para><programlisting>@RooIdentifier(dbManaged = true)
public class LineItemPK {
}</programlisting></para>

      <para>Roo will automatically generate the entity ITD containing a field
      annotated with @EmbeddedId with type LineItemPK as follows:</para>

      <para><programlisting>privileged aspect LineItem_Roo_Entity {
    
    declare @type: LineItem: @Entity;
    
    declare @type: LineItem: @Table(name = "line_item", schema = "order");
    
    @PersistenceContext
    transient EntityManager LineItem.entityManager;
    
    @EmbeddedId
    private LineItemPK LineItem.id;
    
    public LineItemPK LineItem.getId() {
        return this.id;
    }
    
    public void LineItem.setId(LineItemPK id) {
        this.id = id;
    }
...
}</programlisting></para>

      <para>and an identifier ITD for the LineItemPK class containing the
      primary key fields and the type annotation for @Embeddable, as
      follows:</para>

      <para><programlisting>privileged aspect LineItemPK_Roo_Identifier {
    
    declare @type: LineItemPK: @Embeddable;
    
    @Column(name = "line_item_id", nullable = false)
    private BigDecimal LineItemPK.lineItemId;
    
    @Column(name = "order_id", nullable = false)
    private BigDecimal LineItemPK.orderId;
    
    public LineItemPK.new(BigDecimal lineItemId, BigDecimal orderId) {
        super();
        this.lineItemId = lineItemId;
        this.orderId = orderId;
    }

    private LineItemPK.new() {
        super();
    }
...
}</programlisting></para>

      <para>If you decide that your table does not require a composite primary
      key anymore, the next time you execute the database reverse engineer
      command, Roo will automatically change the entity to use a single
      primary key and remove the identifier class if it is permitted.</para>
    </section>

    <section>
      <title>Entity relationships</title>

      <para>One of the powerful features of DBRE is its ability to create
      relationships between entities automatically based on the foreign key
      information in the .roo-dbre XML file. The following associations can be
      generated:<itemizedlist>
          <listitem>
            <emphasis role="bold">Many-valued associations with many-to-many
            multiplicity</emphasis>

            <para>Many-to-many associations are created if a join table is
            detected by DBRE. To be identified as a many-to-many join table,
            the table must have have exactly two primary keys and have exactly
            two foreign-keys pointing to other entity tables and have no other
            columns.</para>

            <para>For example, the database contains a product table and a
            supplier table. The database has been modelled such that a product
            can have many suppliers and a supplier can have many products. A
            join table called product_supplier also exists and links the two
            tables together by having a composite primary key made up of the
            product id and supplier id and foreign keys pointing to each of
            the primary keys of the product and supplier tables. DBRE will
            generate a bi-directional many-to-many association. DBRE will
            designate which entities are the owning and inverse sides of the
            association respectively and annotate the generated fields
            accordingly as shown in the following code snippets:</para>

            <para>
              <programlisting>privileged aspect Product_Roo_DbManaged {
    
    @ManyToMany
    @JoinTable(name = "product_supplier", joinColumns = { @JoinColumn(name = "prod_id") }, inverseJoinColumns = { @JoinColumn(name = "supp_id") })
    private Set&lt;Supplier&gt; Product.suppliers;
...
}</programlisting>

              <programlisting>privileged aspect Supplier_Roo_DbManaged {
    
    @ManyToMany(mappedBy = "suppliers")
    private Set&lt;Product&gt; Supplier.products;
...
}</programlisting>
            </para>

            <para>DBRE will also create many-to-many associations where the
            two tables each have composite primary keys. For example:</para>

            <para>
              <programlisting>privileged aspect Foo_Roo_DbManaged {

    @ManyToMany
    @JoinTable(name = "foo_bar", joinColumns = { @JoinColumn(name = "foo_bar_id1", referencedColumnName = "foo_id1"), @JoinColumn(name = "foo_bar_id2", referencedColumnName = "foo_id2") }, inverseJoinColumns = { @JoinColumn(name = "foo_bar_id1", referencedColumnName = "bar_id1"), @JoinColumn(name = "foo_bar_id2", referencedColumnName = "bar_id2") })
    private Set&lt;Bar&gt; Foo.bars;
...
}
</programlisting>
            </para>
          </listitem>

          <listitem>
            <emphasis role="bold">Single-valued associations to other entities
            that have one-to-one multiplicity</emphasis>

            <para>If the foreign key column represents the entire primary key
            (or the entire index) then the relationship between the tables
            will be one to one and a bi-directional one-to-one association is
            created.</para>

            <para>For example, the database contains a customer table and an
            address table and a customer can only have one address. The
            following code snippets show the one-to-one mappings:</para>

            <para>
              <programlisting>privileged aspect Address_Roo_DbManaged {
    
    @OneToOne
    @JoinColumn(name = "address_id")
    private Party Address.customer;
...
}</programlisting>

              <programlisting>privileged aspect Customer_Roo_DbManaged {
    
    @OneToOne(mappedBy = "customer") 
    private Address Party.address;
...
}</programlisting>
            </para>
          </listitem>

          <listitem>
            <emphasis role="bold">Many-valued associations with one-to-many
            multiplicity</emphasis>

            <para>If the foreign key column is part of the primary key (or
            part of an index) then the relationship between the tables will be
            one to many. An example is shown below:</para>

            <para>
              <programlisting>privileged aspect Order_Roo_DbManaged {
    
    @OneToMany(mappedBy = "order")
    private Set&lt;LineItem&gt; Order.lineItems;
...
}</programlisting>
            </para>
          </listitem>

          <listitem>
            <emphasis role="bold">Single-valued associations to other entities
            that have many-to-one multiplicity</emphasis>

            <para>When a one-to-many association is created, for example a set
            of LineItem entities in the Order entity in the example above,
            DBRE will also create a corresponding many-to-one association in
            the LineItem entity, as follows:</para>

            <para>
              <programlisting>privileged aspect LineItem_Roo_DbManaged {
    
    @ManyToOne
    @JoinColumn(name = "order_id", referencedColumnName = "order_id")
    private Order LineItem.order;
...
}</programlisting>
            </para>
          </listitem>
        </itemizedlist></para>

      <para>DBRE wil ensure generated field names are not duplicated. For
      example, if an entity has more than association to another entity, the
      field names will be generated with unique names. The folllowing code
      snippet illustrates this:</para>

      <para><programlisting>privileged aspect Foo_Roo_DbManaged {

    @ManyToMany
    @JoinTable(name = "foo_bar", joinColumns = { @JoinColumn(name = "foo_bar_id1", referencedColumnName = "foo_id1"), @JoinColumn(name = "foo_bar_id2", referencedColumnName = "foo_id2") }, inverseJoinColumns = { @JoinColumn(name = "foo_bar_id1", referencedColumnName = "bar_id1"), @JoinColumn(name = "foo_bar_id2", referencedColumnName = "bar_id2") })
    private Set&lt;Bar&gt; Foo.bars;

    @ManyToMany
    @JoinTable(name = "foo_com", joinColumns = { @JoinColumn(name = "foo_com_id1", referencedColumnName = "foo_id1"), @JoinColumn(name = "foo_com_id2", referencedColumnName = "foo_id2") }, inverseJoinColumns = { @JoinColumn(name = "foo_com_id1", referencedColumnName = "bar_id1"), @JoinColumn(name = "foo_com_id2", referencedColumnName = "bar_id2") })
    private Set&lt;Bar&gt; Foo.bars1;
...
}</programlisting></para>
    </section>

    <section>
      <title>Other fields</title>

      <para>DBRE will detect column types from the database metadata and
      generate fields and field annotations appropriately. Strings, dates,
      booleans, numeric fields, CLOBs and BLOBs are all supported by
      DBRE.</para>
    </section>
  </section>
</chapter>
